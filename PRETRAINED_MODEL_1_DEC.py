# -*- coding: utf-8 -*-
"""PRETRAINED_DENSENET_22_11_(1)_(1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dctltzPv1BBdwU98QN6sh-Y31omt0ERo
"""

# LIBRARIES
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.utils import to_categorical
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix, auc, roc_curve
import seaborn as sns
from keras.applications import DenseNet121
from tensorflow.keras import layers, models, regularizers, optimizers
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau
from google.colab import drive
from sklearn.metrics import classification_report, confusion_matrix
from google.colab import files

# IMPORTATION OF THE DATA

# Mount Google Drive
drive.mount('/content/drive')
file_dir = "/content/drive/MyDrive/THESIS/"

X_train_augmented = np.load(file_dir + "X_train_augmented_norm.npy")
y_train_augmented = np.load(file_dir + "y_train_augmented.npy")
X_test = np.load(file_dir + "X_test_norm.npy")
y_test = np.load(file_dir + "y_test.npy")
X_val = np.load(file_dir + "X_val_norm.npy")
y_val = np.load(file_dir + "y_val.npy")

# Check the shapes of the loaded data
print(f"X_train_augmented shape: {X_train_augmented.shape}")
print(f"y_train_augmented shape: {y_train_augmented.shape}")
print(f"X_test shape: {X_test.shape}")
print(f"y_test shape: {y_test.shape}")
print(f"X_val shape: {X_val.shape}")
print(f"y_val shape: {y_val.shape}")

# LOSS AND ACCURACY GRAPH

def plot_history(data_list, label_list, title, ylabel):
  epochs = range(1, len(data_list[0]) + 1)
  for data, label in zip(data_list, label_list):
    plt.plot(epochs, data, label=label)
  plt.title(title)
  plt.xlabel('Epochs')
  plt.ylabel(ylabel)
  plt.legend()
  plt.show()

# CONFUSION MATRIX AND CLASSIFICATION REPORT (ACCURACY, PRECISION, RECALL, F1)

def plot_confusion_matrix(y_true, y_pred, class_labels):
    conf_matrix = confusion_matrix(y_true, y_pred)
    plt.figure(figsize=(8, 6))
    sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues',
                xticklabels=class_labels, yticklabels=class_labels)
    plt.title('Confusion Matrix')
    plt.xlabel('Predicted')
    plt.ylabel('True')
    plt.show()

def calculate_metrics(y_true_classes, y_pred_classes):
    accuracy = accuracy_score(y_true_classes, y_pred_classes)
    precision = precision_score(y_true_classes, y_pred_classes, average='weighted')
    recall = recall_score(y_true_classes, y_pred_classes, average='weighted')
    f1 = f1_score(y_true_classes, y_pred_classes, average='weighted')
    return accuracy, precision, recall, f1

# ROC CURVES

def plot_multi_class_roc_curves(y_true, y_scores, n_classes):
    n_classes = y_true.shape[1]
    fpr, tpr, roc_auc = dict(), dict(), dict()
    for i in range(n_classes):
        fpr[i], tpr[i], _ = roc_curve(y_true[:, i], y_scores[:, i])
        roc_auc[i] = auc(fpr[i], tpr[i])
    plt.figure(figsize=(8, 8))
    for i in range(n_classes):
        plt.plot(fpr[i], tpr[i], lw=2, label='ROC curve for class {} (AUC = {:.2f})'.format(i, roc_auc[i]))
    plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--', label='Random')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Multi-class ROC Curves')
    plt.legend(loc='lower right')
    plt.show()

# PRETRAINED DENSENET121 MODEL
from tensorflow.keras import backend as K

densenet_model = DenseNet121(include_top=False, input_shape=(X_train_augmented.shape[1:]))

for layer in densenet_model.layers[:-30]:
    layer.trainable = False

model = models.Sequential()
model.add(densenet_model)
model.add(layers.Flatten())
model.add(layers.Dropout(0.4))
model.add(layers.Dense(9, activation='softmax'))

l2_lambda = 0.01
for weight in model.trainable_weights:
    model.add_loss(l2_lambda * K.sum(K.square(weight)))

optimizer = optimizers.Adam(learning_rate=0.0001)
model.compile(optimizer=optimizer, loss='categorical_crossentropy', metrics=['accuracy'])

early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

model.summary()

# TRAINING OF THE MODEL

history = model.fit(X_train_augmented, y_train_augmented, validation_data=(X_val, y_val), epochs=100, batch_size=50, callbacks=[early_stopping], verbose=1)
print(history.history)

# TRAINING AND VALIDATION ACCURACY/LOSS

accuracy = history.history['accuracy']
val_accuracy = history.history['val_accuracy']
loss = history.history['loss']
val_loss = history.history['val_loss']
epochs = range(1, len(accuracy) + 1)

plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(epochs, accuracy, label='Train')
plt.plot(epochs, val_accuracy, label='Validation', color='orange')
plt.title('Pretrained DenseNet Accuracy', fontsize=14)
plt.xlabel('Epochs', fontsize=12)
plt.ylabel('Accuracy', fontsize=12)
plt.legend(fontsize=10)
plt.grid(False)

plt.subplot(1, 2, 2)
plt.plot(epochs, loss, label='Train')
plt.plot(epochs, val_loss, label='Validation', color='orange')
plt.title('Pretrained DenseNet Loss', fontsize=14)
plt.xlabel('Epochs', fontsize=12)
plt.ylabel('Loss', fontsize=12)
plt.legend(fontsize=10)
plt.grid(False)

plt.tight_layout()
plt.show()

# EVALUATION OF THE TEST SET
y_pred = model.predict(X_test)

y_pred_classes = np.argmax(y_pred, axis=1)
y_true_classes = np.argmax(y_test, axis=1)

accuracy, precision, recall, f1 = calculate_metrics(y_true_classes, y_pred_classes)

print(f"Accuracy: {accuracy:.4f}")
print(f"Precision: {precision:.4f}")
print(f"Recall: {recall:.4f}")
print(f"F1 Score: {f1:.4f}")

print("\nClassification Report:")
print(classification_report(y_true_classes, y_pred_classes, target_names=['1', '2', '3', '4', '5', '6', '7', '8', '9'], digits=4))

class_labels = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
plot_confusion_matrix(y_true_classes, y_pred_classes, class_labels)

plot_multi_class_roc_curves(y_test, y_pred, n_classes=9)

# SAVING THE RESULTS

y_pred = model.predict(X_test)

y_pred_classes = np.argmax(y_pred, axis=1)
y_true_classes = np.argmax(y_test, axis=1)

accuracy, precision, recall, f1 = calculate_metrics(y_true_classes, y_pred_classes)

print(f"Accuracy: {accuracy:.4f}")
print(f"Precision: {precision:.4f}")
print(f"Recall: {recall:.4f}")
print(f"F1 Score: {f1:.4f}")

classification_report_dict = classification_report(
    y_true_classes,
    y_pred_classes,
    target_names=['1', '2', '3', '4', '5', '6', '7', '8', '9'],
    digits=4,
    output_dict=True
)

classification_report_df = pd.DataFrame(classification_report_dict).transpose()

summary_results = {
    'Metric': ['Accuracy', 'Precision', 'Recall', 'F1 Score'],
    'Score': [accuracy, precision, recall, f1]
}
summary_df = pd.DataFrame(summary_results)

classification_report_df.to_csv('classification_report.csv', index=True)
files.download('classification_report.csv')

summary_df.to_csv('summary_metrics.csv', index=False)
files.download('summary_metrics.csv')

conf_matrix = confusion_matrix(y_true_classes, y_pred_classes)

conf_matrix_df = pd.DataFrame(
    conf_matrix,
    index=['1', '2', '3', '4', '5', '6', '7', '8', '9'],
    columns=['1', '2', '3', '4', '5', '6', '7', '8', '9']
)

conf_matrix_df.to_csv('confusion_matrix.csv', index=True)
files.download('confusion_matrix.csv')
print("All results have been saved and are ready for download.")